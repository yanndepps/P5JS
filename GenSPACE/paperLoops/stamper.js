/*
   ____    __    ____      ____    ______ ______           ____    ____    ____       
  /\  _\  _\ \ _/\__ \    /\  _`\ /\__  _/\  _  \  /'\_/`\/\  _`\ /\  _`\ /\  _`\     
  \ \ \/ /\_` ' \/_/\ \   \ \,\L\_\/_/\ \\ \ \L\ \/\      \ \ \L\ \ \ \L\_\ \ \L\ \   
   \ \ \ \/_>   <_ \ \ \   \/_\__ \  \ \ \\ \  __ \ \ \__\ \ \ ,__/\ \  _\L\ \ ,  /   
    \ \ \_ /\_, ,_\ \_\ \    /\ \L\ \ \ \ \\ \ \/\ \ \ \_/\ \ \ \/  \ \ \L\ \ \ \\ \  
     \ \___\/_/\_\/ /\___\   \ `\____\ \ \_\\ \_\ \_\ \_\\ \_\ \_\   \ \____/\ \_\ \_\
      \/___/  \/_/  \/___/    \/_____/  \/_/ \/_/\/_/\/_/ \/_/\/_/    \/___/  \/_/\/ /


Hello and welcome to your Stamper metadata file! 
This file keeps track of all of the info Stamper needs about your stamps. 

Don't worry, it won't affect your sketch if you run it on any other IDE.

Please DON'T MODIFY ANY OF THE INFORMATION BELOW or else your project may behave unexpectantly in Stamper.
However, if your project is acting strangely, delete this file and reopen your project. 
You'll lose your stamps' formatting but keep all of the code.

Happy Stamping :)

*/

{"stamps":[{"id":"j28fpmndv","name":"//  paper loops...","code":"//  paper loops - perlin topology ©kgolid","args":" ","x":407.7260491700566,"y":175.95516828841406,"editorWidth":300,"editorHeight":200,"iframeWidth":0,"iframeHeight":0,"isIndex":false,"isTxtFile":false,"isMediaFile":false,"hidden":false,"exported":true,"zIndex":683,"isBlob":true,"codeSize":14,"icon":"./static/media/globe.50d70b6d.svg","lineHighLightingStatus":"none"},{"id":"4mxtrbrta","name":"let sketch = fu...","code":"let sketch = function(p) {\n    let width = 1400;\n    let height = 1000;\n    let offset = 100;\n\n    let flow_cell_size = 5;\n    \n    let noise_size = 0.0045;\n    let noise_radius = 0.0045;\n\n    let flow_width = (width + offset * 2) / flow_cell_size;\n    let flow_height = (height + offset * 2) / flow_cell_size;\n\n    let noise_grid = [];\n    let flow_grid = [];\n\n    let number_of_particles = 3000;\n    let particles = [];\n\n    let col1, col2;\n\n    let tick = 0;\n    // ---\n    \n    p.setup = function() {\n        let c = p.createCanvas(width, height);\n        p.smooth();\n\n        col1 = p.color(p.random(255), p.random(255), p.random(255), 13);\n        col2 = p.color(p.random(255), p.random(255), p.random(255), 13);\n\n        init_particles();\n        init_flow();\n        \n        p.background(10);\n        p.strokeWeight(2);\n    };\n\n    p.draw = function() {\n        p.translate(-offset, -offset);\n        // display_flow();\n        update_particles();\n        if (tick > 0.1) display_particles();\n        tick += 0.002;\n    };\n    // ---\n\n    function init_particles() {\n        for (let i = 0; i < number_of_particles; i++) {\n            let r = p.random(p.width + 2 * offset);\n            let q = p.random(p.height + 2 * offset);\n            particles.push({\n                prev: p.createVector(r, q),\n                pos: p.createVector(r, q),\n                vel: p.createVector(0, 0),\n                acc: p.createVector(0, 0),\n                col: (p.noise(124 + r / 80, 355 + q / 80) * 280 + 30) % 360,\n                col2: p.lerpColor(col1, col2, p.noise(124 + r / 200, 355 + q / 200)),\n                col3: p.lerpColor(col1, col2, p.noise(r * noise_size, q * noise_size)),\n                seed: i\n            });\n        }\n    }\n\n    function update_particles() {\n       for (let i = 0; i < number_of_particles; i++) {\n           let prt = particles[i];\n           let flow = get_flow(prt.pos.x, prt.pos.y);\n\n           prt.prev.x = prt.pos.x;\n           prt.prev.y = prt.pos.y;\n\n           prt.pos.x = mod(prt.pos.x + prt.vel.x, p.width + 2 * offset);\n           prt.pos.y = mod(prt.pos.y + prt.vel.y, p.height + 2 * offset);\n\n           prt.vel\n              .add(prt.acc)\n              .normalize()\n              .mult(1.5);\n\n           prt.acc = p.createVector(0, 0);\n           prt.acc.add(flow).mult(10);\n       } \n    }\n\n    function init_flow() {\n        for (let i = 0; i < flow_height; i++) {\n            let row = [];\n            for (let j = 0; j < flow_width; j++) {\n                row.push(calculate_flow(j * noise_size, i * noise_size, noise_radius));\n            }\n            flow_grid.push(row);\n        }\n    }\n\n    function calculate_flow(x, y, r) {\n        let high_val = 0;\n        let low_val = 1;\n        let high_pos = p.createVector(0, 0);\n        let low_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 200; i++) {\n            let angle = i / 200 * p.TAU;\n            let pos = p.createVector(x + p.cos(angle) * r, y + p.sin(angle) * r);\n            let val = p.noise(pos.x, pos.y);\n\n            if (val > high_val) {\n                high_val = val;\n                high_pos.x = pos.x;\n                high_pos.y = pos.y;\n            }\n            if (val < low_val) {\n                low_val = val;\n                low_pos.x = pos.x;\n                low_pos.y = pos.y;\n            }\n        }\n\n        let flow_angle = p.createVector(x - high_pos.x, y - high_pos.y);\n        flow_angle\n            .normalize()\n            .mult(20)\n            .mult(high_val - low_val)\n            .rotate(p.HALF_PI);\n\n        return flow_angle;\n    }\n\n    function calculate_flow2(x, y, r) {\n        let diff = 0;\n        let max_diff = 0;\n        let low_pos = p.createVector(0, 0);\n        let high_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 30; i++) {\n            let angle = p.random(p.TAU);\n            let pos1 = p.createVector(x + p.cos(angle) * r, y + p.sin(angle) * r);\n            let pos2 = p.createVector(x + p.cos(angle + p.PI) * r, y + p.sin(angle + p.PI) * r);\n            let val1 = p.noise(pos1.x, pos1.y);\n            let val2 = p.noise(pos2.x, pos2.y);\n\n            diff = p.abs(val2 - val1);\n\n            if (diff > max_diff) {\n                max_diff = diff;\n                if (val1 < val2) {\n                    low_pos.x = pos1.x;\n                    low_pos.y = pos1.y;\n                    high_pos.x = pos2.x;\n                    high_pos.y = pos2.y;\n                } else {\n                    low_pos.x = pos2.x;\n                    low_pos.y = pos2.y;\n                    high_pos.x = pos1.x;\n                    high_pos.y = pos1.y;\n                }\n            }\n        }\n\n        let flow_angle = p.createVector(low_pos.x - high_pos.x, low_pos.y - high_pos.y);\n        flow_angle.normalize().rotate(p.HALF_PI);\n        return flow_angle;\n    }\n\n    function calculate_flow3(x, y, r) {\n        let diff = 100;\n        let min_diff = 100;\n        let low_pos = p.createVector(0, 0);\n        let high_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 50; i++) {\n            let angle1 = i / 50 * p.PI;\n            let pos1 = p.createVector(x + p.cos(angle1) * r, y + p.sin(angle1) * r);\n\n            let valc = p.noise(x, y);\n            let valr = p.noise(pos1.x, pos1.y);\n\n            diff = p.abs(valr - valc);\n\n            if (diff <= min_diff) {\n                min_diff = diff;\n                high_pos.x = pos1.x;\n                high_pos.y = pos1.y;\n            }\n        }\n\n        let flow_angle = p.createVector(x - high_pos.x, y - high_pos.y);\n        flow_angle.normalize().rotate(p.HALF_PI);\n        return flow_angle;\n    }\n\n    function get_flow(xpos, ypos) {\n        xpos = p.constrain(xpos, 0, p.width + offset * 2);\n        ypos = p.constrain(ypos, 0, p.height + offset * 2);\n        return flow_grid[p.floor(ypos / flow_cell_size)][p.floor(xpos / flow_cell_size)];\n    }\n\n    function display_particles() {\n        for (let i = 0; i < particles.length; i++) {\n            p.stroke(particles[i].col2);\n            if (p5.Vector.dist(particles[i].prev, particles[i].pos) < 10) {\n                p.line(particles[i].prev.x, particles[i].prev.y, particles[i].pos.x, particles[i].pos.y); \n            }\n        }\n    }\n\n    function display_flow() {\n        for (let i = 0; i < flow_grid.length; i++) {\n            for (let j = 0; j < flow_grid[i].length; j++) {\n                p.strokeWeight(1);\n                p.stroke(255, 0, 0);\n                p.noFill();\n                p.ellipse(j * flow_cell_size, i * flow_cell_size, 7, 7);\n                p.line(\n                    j * flow_cell_size,\n                    i * flow_cell_size,\n                    j * flow_cell_size + flow_grid[i][j].x * 5,\n                    i * flow_cell_size + flow_grid[i][j].y * 5\n                );\n            }\n        } \n    }\n\n    p.keyPressed = function() {\n        if (p.keyCode == 80) {\n            p.saveCanvas('landslide', 'jpeg');\n        }\n    };\n\n    function mod(x, n) {\n        return (x % n + n) % n;\n    }\n};","args":" ","x":407.7260491700566,"y":475.95516828841403,"editorWidth":300,"editorHeight":200,"iframeWidth":0,"iframeHeight":0,"isIndex":false,"isTxtFile":false,"isMediaFile":false,"hidden":false,"exported":true,"zIndex":684,"isBlob":true,"codeSize":14,"icon":"./static/media/globe.50d70b6d.svg","lineHighLightingStatus":"none"},{"id":"dt668ckoz","name":"new p5(sketch);","code":"new p5(sketch);","args":" ","x":407.7260491700566,"y":775.955168288414,"editorWidth":300,"editorHeight":200,"iframeWidth":0,"iframeHeight":0,"isIndex":false,"isTxtFile":false,"isMediaFile":false,"hidden":false,"exported":true,"zIndex":685,"isBlob":true,"codeSize":14,"icon":"./static/media/globe.50d70b6d.svg","lineHighLightingStatus":"none"},{"id":"80ezty41k","name":"index.html","code":"<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\"/>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/p5.js\"></script>\n        <script src=\"sketch.js\"></script> \n        <title>Paper Loops</title>\n    </head>\n    <body>\n        <style>\n         body {\n             background-color: #000;\n             margin:0;\n             padding: 0;\n             overflow: hidden;\n         }\n         canvas {\n             margin: auto;\n         }\n        </style>\n    </body>\n</html>\n","args":" ","x":407.7260491700566,"y":1075.955168288414,"editorWidth":300,"editorHeight":200,"iframeWidth":100,"iframeHeight":100,"isIndex":true,"isTxtFile":false,"isMediaFile":false,"hidden":true,"exported":true,"isBlob":false,"codeSize":14,"icon":"./static/media/layout.8a437d55.svg","lineHighLightingStatus":"none"}],"scale":0.7,"originX":20,"originY":-114,"worldEdited":false,"snapToGrid":false,"linesOn":false,"js":"\n//  paper loops - perlin topology ©kgolid\n\n\n\nlet sketch = function(p) {\n    let width = 1400;\n    let height = 1000;\n    let offset = 100;\n\n    let flow_cell_size = 5;\n    \n    let noise_size = 0.0045;\n    let noise_radius = 0.0045;\n\n    let flow_width = (width + offset * 2) / flow_cell_size;\n    let flow_height = (height + offset * 2) / flow_cell_size;\n\n    let noise_grid = [];\n    let flow_grid = [];\n\n    let number_of_particles = 3000;\n    let particles = [];\n\n    let col1, col2;\n\n    let tick = 0;\n    // ---\n    \n    p.setup = function() {\n        let c = p.createCanvas(width, height);\n        p.smooth();\n\n        col1 = p.color(p.random(255), p.random(255), p.random(255), 13);\n        col2 = p.color(p.random(255), p.random(255), p.random(255), 13);\n\n        init_particles();\n        init_flow();\n        \n        p.background(10);\n        p.strokeWeight(2);\n    };\n\n    p.draw = function() {\n        p.translate(-offset, -offset);\n        // display_flow();\n        update_particles();\n        if (tick > 0.1) display_particles();\n        tick += 0.002;\n    };\n    // ---\n\n    function init_particles() {\n        for (let i = 0; i < number_of_particles; i++) {\n            let r = p.random(p.width + 2 * offset);\n            let q = p.random(p.height + 2 * offset);\n            particles.push({\n                prev: p.createVector(r, q),\n                pos: p.createVector(r, q),\n                vel: p.createVector(0, 0),\n                acc: p.createVector(0, 0),\n                col: (p.noise(124 + r / 80, 355 + q / 80) * 280 + 30) % 360,\n                col2: p.lerpColor(col1, col2, p.noise(124 + r / 200, 355 + q / 200)),\n                col3: p.lerpColor(col1, col2, p.noise(r * noise_size, q * noise_size)),\n                seed: i\n            });\n        }\n    }\n\n    function update_particles() {\n       for (let i = 0; i < number_of_particles; i++) {\n           let prt = particles[i];\n           let flow = get_flow(prt.pos.x, prt.pos.y);\n\n           prt.prev.x = prt.pos.x;\n           prt.prev.y = prt.pos.y;\n\n           prt.pos.x = mod(prt.pos.x + prt.vel.x, p.width + 2 * offset);\n           prt.pos.y = mod(prt.pos.y + prt.vel.y, p.height + 2 * offset);\n\n           prt.vel\n              .add(prt.acc)\n              .normalize()\n              .mult(1.5);\n\n           prt.acc = p.createVector(0, 0);\n           prt.acc.add(flow).mult(10);\n       } \n    }\n\n    function init_flow() {\n        for (let i = 0; i < flow_height; i++) {\n            let row = [];\n            for (let j = 0; j < flow_width; j++) {\n                row.push(calculate_flow(j * noise_size, i * noise_size, noise_radius));\n            }\n            flow_grid.push(row);\n        }\n    }\n\n    function calculate_flow(x, y, r) {\n        let high_val = 0;\n        let low_val = 1;\n        let high_pos = p.createVector(0, 0);\n        let low_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 200; i++) {\n            let angle = i / 200 * p.TAU;\n            let pos = p.createVector(x + p.cos(angle) * r, y + p.sin(angle) * r);\n            let val = p.noise(pos.x, pos.y);\n\n            if (val > high_val) {\n                high_val = val;\n                high_pos.x = pos.x;\n                high_pos.y = pos.y;\n            }\n            if (val < low_val) {\n                low_val = val;\n                low_pos.x = pos.x;\n                low_pos.y = pos.y;\n            }\n        }\n\n        let flow_angle = p.createVector(x - high_pos.x, y - high_pos.y);\n        flow_angle\n            .normalize()\n            .mult(20)\n            .mult(high_val - low_val)\n            .rotate(p.HALF_PI);\n\n        return flow_angle;\n    }\n\n    function calculate_flow2(x, y, r) {\n        let diff = 0;\n        let max_diff = 0;\n        let low_pos = p.createVector(0, 0);\n        let high_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 30; i++) {\n            let angle = p.random(p.TAU);\n            let pos1 = p.createVector(x + p.cos(angle) * r, y + p.sin(angle) * r);\n            let pos2 = p.createVector(x + p.cos(angle + p.PI) * r, y + p.sin(angle + p.PI) * r);\n            let val1 = p.noise(pos1.x, pos1.y);\n            let val2 = p.noise(pos2.x, pos2.y);\n\n            diff = p.abs(val2 - val1);\n\n            if (diff > max_diff) {\n                max_diff = diff;\n                if (val1 < val2) {\n                    low_pos.x = pos1.x;\n                    low_pos.y = pos1.y;\n                    high_pos.x = pos2.x;\n                    high_pos.y = pos2.y;\n                } else {\n                    low_pos.x = pos2.x;\n                    low_pos.y = pos2.y;\n                    high_pos.x = pos1.x;\n                    high_pos.y = pos1.y;\n                }\n            }\n        }\n\n        let flow_angle = p.createVector(low_pos.x - high_pos.x, low_pos.y - high_pos.y);\n        flow_angle.normalize().rotate(p.HALF_PI);\n        return flow_angle;\n    }\n\n    function calculate_flow3(x, y, r) {\n        let diff = 100;\n        let min_diff = 100;\n        let low_pos = p.createVector(0, 0);\n        let high_pos = p.createVector(0, 0);\n\n        for (let i = 0; i < 50; i++) {\n            let angle1 = i / 50 * p.PI;\n            let pos1 = p.createVector(x + p.cos(angle1) * r, y + p.sin(angle1) * r);\n\n            let valc = p.noise(x, y);\n            let valr = p.noise(pos1.x, pos1.y);\n\n            diff = p.abs(valr - valc);\n\n            if (diff <= min_diff) {\n                min_diff = diff;\n                high_pos.x = pos1.x;\n                high_pos.y = pos1.y;\n            }\n        }\n\n        let flow_angle = p.createVector(x - high_pos.x, y - high_pos.y);\n        flow_angle.normalize().rotate(p.HALF_PI);\n        return flow_angle;\n    }\n\n    function get_flow(xpos, ypos) {\n        xpos = p.constrain(xpos, 0, p.width + offset * 2);\n        ypos = p.constrain(ypos, 0, p.height + offset * 2);\n        return flow_grid[p.floor(ypos / flow_cell_size)][p.floor(xpos / flow_cell_size)];\n    }\n\n    function display_particles() {\n        for (let i = 0; i < particles.length; i++) {\n            p.stroke(particles[i].col2);\n            if (p5.Vector.dist(particles[i].prev, particles[i].pos) < 10) {\n                p.line(particles[i].prev.x, particles[i].prev.y, particles[i].pos.x, particles[i].pos.y); \n            }\n        }\n    }\n\n    function display_flow() {\n        for (let i = 0; i < flow_grid.length; i++) {\n            for (let j = 0; j < flow_grid[i].length; j++) {\n                p.strokeWeight(1);\n                p.stroke(255, 0, 0);\n                p.noFill();\n                p.ellipse(j * flow_cell_size, i * flow_cell_size, 7, 7);\n                p.line(\n                    j * flow_cell_size,\n                    i * flow_cell_size,\n                    j * flow_cell_size + flow_grid[i][j].x * 5,\n                    i * flow_cell_size + flow_grid[i][j].y * 5\n                );\n            }\n        } \n    }\n\n    p.keyPressed = function() {\n        if (p.keyCode == 80) {\n            p.saveCanvas('landslide', 'jpeg');\n        }\n    };\n\n    function mod(x, n) {\n        return (x % n + n) % n;\n    }\n};\n\n\n\nnew p5(sketch);\n\n","highlightedLines":{}}